\p => [ð¬¶¤ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.!?,0123456789:;"'_<=>\*\+\-\/\\\@\#\$\%\&\^\|\(\)\[\]\{\}\`\~]
\c => [ẠḄḌẸḤỊḲḶṂṆỌṚṢṬỤṾẈỴẒȦḂĊḊĖḞĠḢİĿṀṄȮṖṘṠṪẆẊẎŻạḅḍẹḥịḳḷṃṇọṛṣṭụṿẉỵẓȧḃċḋėḟġḣŀṁṅȯṗṙṡṫẇẋẏżƁƇƊƑƓƘƝƤƬƲȤɓƈɗƒɠɦƙɱ]
\m => [°¹²³⁴⁵⁶⁷⁸⁹]
\l => [ɲƥʠɼʂƭʋȥÆÇÐÑØŒÞßæçıȷñøœþ€¢£¥…µ¡¿×÷¦©®«»‘’“”°¹²³⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾]
\k => [\p\c\l ]
\a => [\k\n]


U => unimplemented
I => incomplete
? => unsure about the command

--- NOPs ---
    space     - Use to separate commands.
    new line  - Use to separate commands also ends some scopes of commands.

--- MISC ---
    :;\d+   - Use in a STRING to create a Unicode character based off of the \d+.
 U  ɲ`      - terminate()
 U  ɲ~      - a = i.front() a.props.clear()
 U  ṛ       - a = i.front()
              if a is NUMBER =>
                max, min
                b = i.front()
                if b == undefined => max = MAX(0, a.value) min = MIN(0, a.value)
                else => max = MAX(a.value, b.value) min = MIN(a.value, b.value)
                o.back(NUMBER(random_int(min, max)))
              elif a is ARRAY or a is STRING =>
                o.back(a.access(random_int(0, a.length())))
                o.back(a)
 U  ṛ(\d+)  - o.back(NUMBER(random_int(0, valueOf($1)))
    €       - a = i.first() make_error(a != undefined ? a : STRING("<UNDEFINED>¶"), path);

--- Literals ---
 -- String --
    (\p+)          - if has_null($1) => o.back(ARRAY(split($1, "ð"))) else => o.back(STRING($1))
    “(\c*)         - o.back(STRING(decompress_basic($1)))
    ”(\c*)         - a = string_break(decompress_basic($1)) o.back(ARRAY(a))
 -- Numeric --
    ɲ(-?\d+)       - o.back(NUMBER(valueOf($1)))
    ɲ(-?\d*\.\d+)  - o.back(NUMBER(valueOf($1)))
    ɲ(-)           - o.back(NUMBER(-1))
    ɲ(-?\d*/\d+)   - o.back(NUMBER(valueOf($1)))

--- Operators ---
    ⁺        - a = i.front() b = i.front() o.back(a.add(b))
    ⁻        - a = i.front() b = i.front() o.back(a.sub(b))
    ⁺ʂ       - a = i.front() b = i.front() o.back(a.add_flip(b))
    ⁻ʂ       - a = i.front() b = i.front() o.back(a.sub_flip(b))
    (\m+)⁺   - a = i.front() for c = 0, c < valueOf($1), ++c => a = a.increment(tkn); o.back(a)
    (\m+)⁻   - a = i.front() for c = 0, c < valueOf($1), ++c => a = a.decrement(tkn); o.back(a)
 U  (\m+)⁺ʂ  - a = i.front() for c = 0, c < valueOf($1), ++c => a = a.increment_flip(tkn); o.back(a)
 U  (\m+)⁻ʂ  - a = i.front() for c = 0, c < valueOf($1), ++c => a = a.decrement_flip(tkn); o.back(a)
    µ⁺       - a = i.front() b = i.front()
               if b is NUMBER =>
                 o.back(NUMBER(b.value * a.integerify().value))
               else =>
                 for c = 0, c < a.integerify().value, ++c => b = b.increment(tkn); o.back(b)
    µ⁻       - a = i.front() b = i.front()
               if b is NUMBER =>
                 o.back(NUMBER(b.value / a.integerify().value))
               else =>
                 for c = 0, c < a.integerify().value, ++c => b = b.decrement(tkn); o.back(b)
 U  µ⁺ʂ      - a = i.front() b = i.front()
               if b is NUMBER =>
                 o.back(NUMBER(b.pow(a.integerify().value)))
               else =>
                 for c = 0, c < a.integerify().value, ++c => b = b.increment_flip(tkn); o.back(b)
 U  µ⁻ʂ      - a = i.front() b = i.front()
               if b is NUMBER =>
                 o.back(NUMBER(b.pow(1 / a.integerify().value)))
               else =>
                 for c = 0, c < a.integerify().value, ++c => b = b.decrement_flip(tkn); o.back(b)

--- Array Like Operators ---
 I  ɲ_        - a = i.front()
                if a is NUMBER => o.back(NUMBER(a.floor()))
                elif a is STRING => foreach s in a.value => o.back(STRING(s))
                elif a is ARRAY => foreach e in a.value => o.back(e)
 I  ɲl        - a = i.front() o.back(NUMBER(a.length())) # For numbers that means abs.
    ẹ         - a = i.front()
                if a is NUMBER => o.back(NUMBER(a.reciprocal()))
                elif a is STRING => o.back(STRING(a.value.slice(1, a.length()) + a.value.slice(0, 1)))
                elif a is ARRAY => a.value.unshift(a.value.pop())
 U  Ẹ         - a = i.front()
                if a is NUMBER => o.back(NUMBER(a.square_root()))
                elif a is STRING => len = a.length() o.back(STRING(a.value.slice(len - 1, len) + a.value.slice(0, len - 1)))
                elif a is ARRAY => a.value.push(a.value.shift())
 I  ạ         - a = i.front()
                index = undefined
                delta = undefined
                count = undefined
                if a is NUMBER => index = a.value delta = a.sign() a = i.front() if a == undefined => o.back(NUMBER(index + delta)) exit
                if a is NUMBER => count = a.value a = i.front() if a = undefined => o.back(NUMBER(index + (delta * count))) exit
                if a is NUMBER => o.back(NUMBER(abs((index + (delta * count))%a.value)))
                elif a is STRING or ARRAY =>
                  if a is STRING => a = ARRAY(string_break(a.value))
                  if index == undefined => index = a.props("frame")
                  if index == undefined => index = 0 delta = 1
                  if count == undefined => count = a.props("frame_count")
                  if count == undefined => count = a.length()
                  if delta == undefined => delta = a.props("frame_delta")

                  if count != 0 =>
                    index = a.correct_index(index)
                    o.back(a.access(index))
                    index += delta
                    --count
 
                  if count == 0 =>
                    a.props("frame_count", undefined)
                    a.props("frame", undefined)
                    a.props("frame_delta", undefined)
                  else =>
                    a.props("frame_count", count)
                    a.props("frame", index)
                    a.props("frame_delta", delta)
                  
                  o.back(a)
 I  ạ(-?\d*)  - a = i.front()
                index = $1 == "-" ? -1 : valueOf($1)
                delta = $1.contains("-") ? -1 : 1
                count = undefined
                if a is NUMBER => count = a.value a = i.front() if a = undefined => o.back(NUMBER(index + (delta * count))) exit
                if a is NUMBER => o.back(NUMBER(abs((index + (delta * count))%a.value)))
                elif a is STRING or ARRAY =>
                  if a is STRING => a = ARRAY(string_break(a.value))
                  if a.props("frame") != undefined => index = a.props("frame")
                  if count == undefined => count = a.props("frame_count")
                  if count == undefined => count = a.length()

                  if count != 0 =>
                    index = a.correct_index(index)
                    o.back(a.access(index))
                    index += delta
                    --count
 
                  if count == 0 =>
                    a.props("frame_count", undefined)
                    a.props("frame", undefined)
                    a.props("frame_delta", undefined)
                  else =>
                    a.props("frame_count", count)
                    a.props("frame", index)
                    a.props("frame_delta", delta)
                  
                  o.back(a)

--- Casting ---
 I  ɲ'      - a = i.front()
              if a is ARRAY => foreach e in a.value => e = e.stringify(); o.back(a)
              elif a is NUMBER o.back(a.stringify())
              else o.back(a.reverse())
 I  ɲ#      - a = i.front()
              if a is ARRAY => foreach e in a.value => e = e.numberify(); o.back(a)
              elif a is STRING o.back(a.numberify())
              else o.back(NUMBER(a.sign_flip()))
 U  ɲ       - a = i.front()
              if a is ARRAY => foreach e in a.value => e = e.numberify(); o.back(a)
              elif a is STRING => a = ARRAY(string_null_break(a.value)) foreach e in a.value => NUMBER(valueOf(a.value[i])); o.back(a)
              elif a is NUMBER => o.back(NUMBER(-1 * a.abs()))
    œ       - a = [] a.pipe(i) if a.length() != 0 => o.back(ARRAY(a))
    œ(\d+)  - a = [] c = valueOf($1) while c != 0 and i.first() != undefined => a.push(i.front()); if a.length() != 0 => o.back(ARRAY(a))
    µœ      - a = i.front() if a != undefined => a = a.integerify() b = [] while a.value != 0 and i.first() != undefined => b.push(i.front()) --a.value; o.back(ARRAY(b))
 I  ʋ       - a = i.front()
              if a is NUMBER => o.back(NUMBER(a.ceilling()))
              elif a is STRING => a = string_break(a.value) foreach e in a => o.back(STRING(e))
              elif a is ARRAY => ???

--- Loops ---
    ḷ(\k*)       - while(true) => $1
    Ḷ(\k*)       - if tkn.count == undefined => tkn.count = a.integerify().value
                   while(0 < tkn.count) => $1 tkn.count--
                   tkn.count = undefined
    Ḷ(\d+)(\k*)  - if tkn.count == undefined => tkn.count = valueOf($1)
                   while(0 < tkn.count) => $2 tkn.count--
                   tkn.count = undefined
    ṃ(\k*)       - while(i.first().is_truthy().value == 1) $1
    Ṃ(\k*)       - while(i.front().is_truthy().value == 1) $1
    ḅ            - break from a loop that is before this command and that does not have a break.
    Ḅ            - a = i.front() if a != undefined && a.is_truthy().value == 1 => i.front(a) else => ḅ

--- Time ---
    ḍ              - a = i.front() delay_ms(i.integerify().value)
    ḍ(\d+)         - delay_ms(valueOf($1))
    ḍ[shqe]        - if $1 == "s" => delay_ms(1000)
                     elif $1 == "h" => delay_ms(500)
                     elif $1 == "q" => delay_ms(250)
                     elif $1 == "e" => delay_ms(125)
    ḍ(\d*)/(\d*)   - num = 1000 den = 1
                     if $1.length > 0 => num *= valueOf($1)
                     if $2.length > 0 => den = valueOf($1)
                     delay_ms(num / den)
    ḍ(\d*)\.(\d*)  - delay_ms(valueOf("0" + $1 + "." + $2 + "0") * 1000)

--- Printing ---
    þ - path.o.back(i.first())
    Þ - path.o.back(i.front())
    ç - path.o.wipe() path.o.back(i.first())
    Ç - path.o.wipe() path.o.back(i.front())
    ñ - path.o.back(i.first()) path.o.back(STRING("¶"))
    Ñ - path.o.back(i.front()) path.o.back(STRING("¶"))

--- Pipe Manipulation ---
    ḃ - i.front()
    Ḃ - i.wipe()
    ė - i.back(i.front())
    Ė - i.front(i.back())
    ʂ - a = i.front() b = i.front() o.back(b) o.back(a)

--- String Manipulation ---
 U  ʠ - s = i.front()
        if s is STRING =>
          a = i.front()
          if a is STRING => a = ARRAY(string_break(a.value))
          if a is ARRAY =>
            s = s.value
            foreach /%(\d)%/ in s => replace(a.access($1.length === 0 ? 0 : valueOf($1)).stringify().value)
            o.back(STRING(s))
          elif a is NUMBER => ???
        elif s is ARRAY => ???
        elif s is NUMBER => ???

--- Conditionals ---
 U  ⁼         - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(0))
                elif b == undefined => o.back(a.is_truthy()) o.back(a)
                else => o.back(a.equals(b)) o.back(a) o.back(b)
 U  ⁼ʂ        - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(1))
                elif b == undefined => o.back(a.is_falsy()) o.back(a)
                else => o.back(a.equals_flip(b)) o.back(a) o.back(b)
 U  ⁼<        - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(-1)) ???
                elif b == undefined => o.back(a.min()) o.back(a) ???
                else => o.back(a.lt(b)) o.back(a) o.back(b)
 U  ⁼<ʂ       - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(-100)) ???
                elif b == undefined => o.back(a.min()) o.back(a) ???
                else => o.back(a.lt_flip(b)) o.back(a) o.back(b)
 U  ⁼>        - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(.1)) ???
                elif b == undefined => o.back(a.max()) o.back(a) ???
                else => o.back(a.gt(b)) o.back(a) o.back(b)
 U  ⁼>ʂ       - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(100)) ???
                elif b == undefined => o.back(a.max()) o.back(a) ???
                else => o.back(a.gt_flip(b)) o.back(a) o.back(b)
 U  ⁼!        - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(16)) ???
                elif b == undefined => o.back(a.is_truthy()) o.back(a) ???
                else => o.back(NUMBER(a.equals(b).value == 0 ? 1 : 0)) o.back(a) o.back(b)
 U  ⁼!ʂ       - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(256)) ???
                elif b == undefined => o.back(a.is_falsy()) o.back(a) ???
                else => o.back(NUMBER(a.equals_flip(b).value == 0 ? 1 : 0)) o.back(a) o.back(b)
 U  ⁼,        - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(-1)) ???
                elif b == undefined => o.back(a.min()) o.back(a) ???
                else => o.back(a.lte(b)) o.back(a) o.back(b)
 U  ⁼,ʂ       - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(-100)) ???
                elif b == undefined => o.back(a.min()) o.back(a) ???
                else => o.back(a.lte_flip(b)) o.back(a) o.back(b)
 U  ⁼.        - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(.1)) ???
                elif b == undefined => o.back(a.max()) o.back(a) ???
                else => o.back(a.gte(b)) o.back(a) o.back(b)
 U  ⁼.ʂ       - a = i.front() b = i.front()
                if a == undefined => o.back(NUMBER(100)) ???
                elif b == undefined => o.back(a.max()) o.back(a) ???
                else => o.back(a.gte_flip(b)) o.back(a) o.back(b)
    ⁽(\a*)⁾   - a = i.front() if a.is_truthy().value == 1 => $1
    ⁽(\a*)⁾e  - a = i.front() if a.is_truthy().value == 1 => $1 else => o.back(NUMBER(1))

--- All Characters ---
ð¬¶¤ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.!?,0123456789:;"'_<=>*+-/\@#$%&^|()[]{}`~
ẠḄḌẸḤỊḲḶṂṆỌṚṢṬỤṾẈỴẒȦḂĊḊĖḞĠḢİĿṀṄȮṖṘṠṪẆẊẎŻạḅḍẹḥịḳḷṃṇọṛṣṭụṿẉỵẓȧḃċḋėḟġḣŀṁṅȯṗṙṡṫẇẋẏżƁƇƊƑƓƘƝƤƬƲȤɓƈɗƒɠɦƙɱ
ɲƥʠɼʂƭʋȥÆÇÐÑØŒÞßæçıȷñøœþ€¢£¥…µ¡¿×÷¦©®«»‘’“”°¹²³⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾
